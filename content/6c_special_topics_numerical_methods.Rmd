---
title: "Laplace and AGHQ"
author: "NIMBLE Development Team"
date: "`r Sys.Date()`"
output: html_document
---

```{css, echo = FALSE}
h1, h4.author, h4.date {
  text-align: center;
}
```

```{r setup, include=FALSE, echo = FALSE}
knitr::opts_chunk$set(echo = TRUE)

knitr_opts <- list(
  message = FALSE,
  warning = FALSE,
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  dpi = 300,
  out.width = "700px",
  fig.asp = 1 / 1.618,
  cache = FALSE,
  autodep = TRUE,
  cache.comments = TRUE,
  fig.align = "center",
  echo = TRUE,
  results = 'hide',
  eval = FALSE
)
do.call(knitr::opts_chunk$set, knitr_opts)
```

## Beta Binomial Example?

```{r}
pars <- claplace$getNodeNamesVec()

claplace$updateSettings(nQuad = 1)
loglik1 <- claplace$calcLogLik(p = values(model, pars))
claplace$updateSettings(nQuad = 3)
loglik3 <- claplace$calcLogLik(p= values(model, pars))
claplace$updateSettings(nQuad = 11)
loglik11 <- claplace$calcLogLik(p = values(model, pars))
```


## Example Fraser Sockeye (again)

See module 2, "intro_to_nimble" for information on this example. We will consider the hierarchical model 

```{r, eval = TRUE}
library(tidyverse)
library(readxl)
sockeye <- read_excel("data/Production Data_Detailed Format.xlsx")
stockid <- "Stellako"
sox <- sockeye %>% 
  filter(production_stock_name == stockid) %>%
  group_by(broodyr, total_broodyr_spawners) %>%
  summarize(recruits=sum(num_recruits), .groups = "drop") %>%
  rename(broodyear = broodyr, spawners = total_broodyr_spawners) %>%
  mutate(logRS = log(recruits) - log(spawners)) %>%
  filter(!is.na(spawners) & !is.na(recruits)) %>%
  mutate(scale = 10^floor(log10(max(spawners))))

spscale <- sox$scale[1]
```

We will use the code chunk below from the previous module to get started.

```{r}
library(nimble)
sox <- sox %>% arrange(broodyear)
deltat <- sox$broodyear - lag(sox$broodyear)
  
sox_model_MA1 <- nimbleCode({
  # Priors
  logalpha ~ dnorm(1.5, sd = 10)
  sigma ~ dunif(0, 10)
  logE ~ dnorm(2, sd = 3)
  E <- exp(logE)
  rho ~ T(dnorm(0,1), -1, 1)  ## Correlation term. Truncated.
  
  ## Compute mean
  mean_logRS[1:nobs] <- logalpha*(1-S[1:nobs]/E)  ## Vector notation.

  # Likelihood:
  logRS[1] ~ dnorm(mean_logRS[1], sd = sigma)
  for( i in 2:nobs ){
    mean_logRS_t[i] <- mean_logRS[i] + (mean_logRS[i-1] - logRS[i-1])*rho^deltat[i]
    logRS[i] ~ dnorm(mean_logRS_t[i], sd = sigma*sqrt(1-rho^(2*deltat[i])))
  }
})

model <- nimbleModel(sox_model_MA1,
                    constants = list(nobs = nrow(sox), S = sox$spawners/spscale, deltat = deltat),
                    data = list(logRS = sox$logRS),
                    inits = list(logalpha = 1.5, delta = 0.25, logE = 2, sigma = 0.5, rho = 0), 
                    buildDerivs = TRUE)
cmodel <- compileNimble(model)

conf <- configureMCMC(model, monitors = c("logE", "sigma", "rho", "logalpha"))
mcmc <- buildMCMC(conf)
## Compile the MCMC
cmcmc <- compileNimble(mcmc)

inits <- function(){
  list(sigma = runif(1,0.1,3), logalpha = rnorm(1, 1.5, 3), logE = rnorm(1, 4, 2))
}

samples <- runMCMC(cmcmc, niter = 10000, nburnin = 2000, 
                    inits = inits(), nchains = 3, samplesAsCodaMCMC = TRUE)

plot(samples[, "logE"])

samp.sum <- data.frame(do.call('cbind', summary(samples)))
samp.sum$param <- rownames(samp.sum)
samp.sum$method <- "MCMC"
samp.sum$lci <- samp.sum$X2.5.
samp.sum$uci <- samp.sum$X97.5.

rlaplace <- buildLaplace(model)
claplace <- compileNimble(rlaplace)
mle <- claplace$findMLE()
mle.sum <- claplace$summary(mle)
mle.sum$params
out <- rbind(samp.sum[, c("param", "Mean", "SD", "lci", "uci", "method")], 
    data.frame(param = mle.sum$params$names, Mean = mle.sum$params$estimate, 
      SD = mle.sum$params$stdError, lci = mle.sum$params$estimate - 1.96*mle.sum$params$stdError, 
      uci = mle.sum$params$estimate + 1.96*mle.sum$params$stdError, method = "Laplace"))

ggplot(data = out, aes(x = param, y = Mean, colour = method)) + 
  geom_point(position = position_dodge(0.2)) +
  geom_errorbar(aes(ymin = lci, ymax = uci), width = 0.01, position = position_dodge(0.2)) +
  theme_bw()

mle.logE <- out %>% filter(param == "logE", method == "Laplace")
plot(samples[, "logE"], trace = FALSE)
abline(v = mle.logE$Mean, col = 'red', lty = 2)
lines(x = c(mle.logE[, "lci"], mle.logE[, "uci"]), y = c(0.02, 0.02), col = 'red', cex = 2)
## We can see the symmetry assumption from the MLE is probably making this Wald CI poor.
```

***Discuss Wald CI***

## See the wildness of the dflat again to compare with the MLE...
